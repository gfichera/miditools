#! /usr/bin/perl
#########################################################################
#        This Perl script is Copyright (c) 2012, Peter J Billam         #
#                          www.pjb.com.au                               #
#                                                                       #
#     This script is free software; you can redistribute it and/or      #
#            modify it under the same terms as Perl itself.             #
#########################################################################

# quantise ? into fractions of the Bar ? with inegale/swing/lilt ?
# ability do define Macros ? e.g. to mute 3 channels and unmute 3,
#  real fast in order to switch between verse and chorus

# 20131227 MUST be able to convert muscript source via midi to a loopsetfile

#use strict;
#use warnings;

use Data::Dumper; $Data::Dumper::Sortkeys = 1; # $Data::Dumper::Indent = 0;

use Time::HiRes();
select STDERR; $|=1; select STDOUT;
my $Version      = '2.0';  # @LoopChannels convenience variable eliminated
my $VersionDate  = '24feb2013';

my $RecordingChannel = undef;
my $InputPort     = '';
my $OutputPort    = '';
my @L             = (); # @Loopsets 1.8 LoH of BarLength and Channels
my $NextLoopset   = undef;  # the change will occur at the next barline
my $IL            = 0;  # $CurrentLoopset mnemonic $i_loop
my @Cha2Patch     = (); # automatic; midiloop fills this in by eavesdropping
# each Loopset remembers these channels independently;
# this can be saved in a .mid file by replaying any patch_changes
# just before "recording" the channels, just like in realtime.
my $StartOfBar    = 0;  # set by the play loop, needed also when recording
my $BarCount      = -1; # gets incremented at the start of each loop-bar
my $WithMetronome = 0;
my $Paused        = 1;  # this is global, governing all loopsets
my $LoopStart     = 0;  # floating-point seconds
my @LoopEvents    = (); # alsa_events with NOTEONs and OFFs combined into NOTEs
my $LoopIndex     = $[; # the event within the loop
my $IsCmdMode     = 0;  # are we in command-mode ?
my $CmdModePedal  = 67; # default is 67, the UnaCorda pedal
my $CurrentMuteset = 0;
my @Mutesets      = (); # list of array-refs
my %MutsetScore   = (); # modbarcount-to-mutesetnum, generated by GoToMutesets
my $Message       = '';
my @Num2Cmd       = (   # order: global,channel,loopset) :
	'Pause', 'Play', 'Mute', 'Unmute',
	'Record', 'Barlength',
	# if channels already recorded, change barlength speeds up the whole loop
	'NewMuteset', 'GotoMuteset', 'EraseMuteset',
	'NewLoopset', 'GotoLoopset', 'EraseLoopset',
	'SaveLoopsets', 'LoadLoopsets', 'Quit'
);
my @RelevantCmds = (0..15);   # will get reevaluated by relevant_cmds()
my @Num2Barlength = (  # I'm always using only the shortest ones...
	1.00, 1.11, 1.24, 1.38, 1.54, 1.71, 1.90, 2.12,
	2.36, 2.63, 2.92, 3.25, 3.62, 4.03, 4.49, 5.00
);
my %Pitch2Number88 = (
	62,0, 64,1, 65,2, 67,3, 69,4, 71,5, 72,6, 74,7,
	76,8, 77,9, 79,10,81,11,83,12,84,13,86,14,88,15,
);
my %Pitch2Number49 = (
	38,0, 40,1, 41,2, 43,3, 45,4, 47,5, 48,6, 50,7,
	52,8, 53,9, 55,10,57,11,59,12,60,13,62,14,64,15,
);
my %Pitch2Number25 = (
	62,0, 63,1, 64,2, 65,3, 66,4, 67,5, 68,6, 69,7, 70,8, 71,9, # trouble
);
my %Pitch2Number = %Pitch2Number88; # adjust to what keys user plays, or to -k
my $ModeChangeKey  = 108;
my $Home = $ENV{'LOGDIR'} || $ENV{'HOME'} || (getpwuid($>))[$[+7];
my $MidiloopDir = $ENV{'MIDILOOP_DIR'} || "$Home/midiloop";  # or -d option
$| = 1;   # autoflush on STDOUT

# vt100 globals
my $CursorRow    = 7;
my $Irow         = 1;
my $Icol         = 1;
my $COLS         = 80;
my $ROWS         = 25;
eval 'require "Term/ReadKey.pm"';
if (! $@) {
	($COLS, $ROWS) = Term::ReadKey::GetTerminalSize(*STDERR);
	Term::ReadKey::ReadMode(2);
} else {
	eval 'require "Term/Size.pm"';   #warn "trying Term::Size\n";
	if (! $@) { ($COLS, $ROWS) = Term::Size::chars(*STDERR); }
}
#warn "COLS=$COLS ROWS=$ROWS\n";

use open ':locale';
eval 'require MIDI::ALSA'; if ($@) {
	die "you'll need to install the MIDI-ALSA module from www.cpan.org\n";
}

my @cmd = grep ($_ ne '-X', @ARGV);
while ($ARGV[$[] =~ /^-([a-z]|X)/) {
	if ($1 eq 'v')      { shift;
		my $n = $0; $n =~ s{^.*/([^/]+)$}{$1};
		print "$n version $Version $VersionDate\n";
		exit 0;
	} elsif ($1 eq 'd') { shift; $MidiloopDir = shift;
	} elsif ($1 eq 'k') { shift; my $k      = shift;   # must change 108 also
		if      ($k eq '88') { %Pitch2Number = %Pitch2Number88;
		} elsif ($k eq '49') {
			$ModeChangeKey = 84;
			%Pitch2Number = %Pitch2Number49;
		} elsif ($k eq '25') {
			$ModeChangeKey = 72;   # ouch...
			%Pitch2Number = %Pitch2Number25;
		} else { die "bad -k arg: $k, should be 88, 49 or 25\n";
		}
	} elsif ($1 eq 'l') { shift; my $f = shift;
		if (! load_loopset($f)) { exit; }
	} elsif ($1 eq 'i') { shift; $InputPort  = shift;
	} elsif ($1 eq 'o') { shift; $OutputPort = shift;
#	} elsif ($1 eq 'X') {
#		exec 'xterm -geometry 80x7-1+1 -exec midiloop '.join(' ',@cmd).' &';
#		die " exec failed: $!\n";
	} else {
		print "usage:\n";  my $synopsis = 0;
		while (<DATA>) {
			if (/^=head1 SYNOPSIS/)     { $synopsis = 1; next; }
			if ($synopsis && /^=head1/) { last; }
			if ($synopsis && /\S/)      { s/^\s*/   /; print $_; next; }
		}
		exit 0;
	}
}

# code based on midiecho's RealTime mode....

if (!$OutputPort) { $OutputPort = $ENV{'ALSA_OUTPUT_PORTS'}; }
if (!$OutputPort) {
	warn "OutputPort not specified and ALSA_OUTPUT_PORTS not set\n";
}
MIDI::ALSA::client( "midiloop pid=$$", 1, 1, 1 );
foreach my $cl_po (split /,/, $InputPort) {
	if (! MIDI::ALSA::connectfrom( 0, $cl_po )) {
		die "can't connect from ALSA client $cl_po\n";
	}
}
foreach my $cl_po (split /,/, $OutputPort) {  # 3.6
	if (! MIDI::ALSA::connectto( 1, $cl_po )) {
		die "can't connect to ALSA client $cl_po\n";
	}
}
if (! MIDI::ALSA::start()) {
	die "can't start the queue of the ALSA client\n";
}

END {
    foreach my $c (0..15) {  # all notes off
        MIDI::ALSA::output(MIDI::ALSA::controllerevent($c,120,0));
	}
	clrtoeos();
	print STDERR "\n";
	Term::ReadKey::ReadMode(0);  
}
$SIG{'INT'} = sub {
	exit;
};

$SIG{'ALRM'} = sub {    # play one bar, and increment the BarCount
	if (defined $NextLoopset) {  # a change! ; swap to the new loop
		my $default_bl = $L[$IL]{'BarLength'} || 1.0,
		$IL = $NextLoopset;
		undef $NextLoopset;
		if (! defined $L[$IL]{'BarLength'}) {
			my @tmp  = @{$L[$IL]{'Channels'}};   # should deepcopy ?
			$L[$IL] = { BarLength => $default_bl, Channels => \@tmp };
		}
		$BarCount = -1;
		output_patch_changes();
		display_loopsets();
		display_channels();
	}
	if ($Paused) { return; }
	$BarCount += 1;   # restarts from -1 when the Loopset changes
	my ($queue_running,$now,$events) = MIDI::ALSA::status();
	$StartOfBar = $now;
	if (defined $RecordingChannel) {
		my $modbarcount = mod_bar_count($RecordingChannel);
		display_recording($modbarcount);
		if ($WithMetronome) {
			my $key = 33;  if ($modbarcount < 0.5) { $key = 34; }
			MIDI::ALSA::output(MIDI::ALSA::noteevent(9,$key,70,$now,0.2));
		}
	}
	my %is_unmuted = is_unmuted();
	# also do_recording needs to know when the start of the bar was
	foreach my $cha (keys %is_unmuted) {
		my $i_bar = mod_bar_count($cha);
		my $cha_ref = $L[$IL]{'Channels'}[$cha];
		my $patch = $cha_ref->{'Patch'};
		if ($Cha2Patch[$cha] != $patch) {
			MIDI::ALSA::output(MIDI::ALSA::pgmchangeevent($cha, $patch));
			$Cha2Patch[$cha] = $patch;
		}
		my @events = @{$cha_ref->{'LoopBars'}[$i_bar]};
		foreach my $event_ref (@events) {
			my @alsaevent = @{$event_ref};   # take a copy
			$alsaevent[4] += $StartOfBar;
			MIDI::ALSA::output(@alsaevent);
		}
	}
	if ($L[$IL]{'BarLength'} < 0.2) { do_recording(); }
	Time::HiRes::ualarm(1000000*$L[$IL]{'BarLength'});   # Sec to uSec
};

display_paused();
display_loopsets();
display_channels();
display_keystrokes();

while (1) {   # alternate between play-mode and command-mode
	$IsCmdMode = 0;   # play-mode
	display_keystrokes();
	while (1) {
		my @alsaevent = MIDI::ALSA::input();
		if (is_mode_change(@alsaevent)) { last; }
		MIDI::ALSA::output(@alsaevent);   # straight-through real-time output
		remember_patch_change(@alsaevent);

	}
	$IsCmdMode = 1;   # command-mode
	display_keystrokes();
	my $n = ask_n('do what', $CursorRow, \@RelevantCmds);
	if (defined $n) { handle_command($Num2Cmd[$n]); }  # ^C to quit :-)
}
exit 0;

#------------------------ infrastructure ----------------------------

sub round { my $x = $_[$[];
    if ($x > 0.0) { return int ($x + 0.5); }
    if ($x < 0.0) { return int ($x - 0.5); }
    return 0;
}

sub is_mode_change {
	if (
	  ($_[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEON()
	    and $_[$#_][1] == $ModeChangeKey)
	  or
	  ($_[0] == MIDI::ALSA::SND_SEQ_EVENT_CONTROLLER()
	    and $_[$#_][4] == 64
	    and $_[$#_][5] > 63
	  )) { return 1;
	} else {
		return 0;
	}
}

sub debug {
	open (T, '>>', '/tmp/debug');
	print T $_[$[],"\n";
	close T;
}

sub empty_loop_bars { my $nbars = $_[$[];
	my @a = ();
	foreach (1..$nbars) { push @a, []; }  # each bar is a ref to an empty list
	return \@a;
}

sub display_paused {
	gotoxy(2,1);
	if ($Paused) { puts_clr('Paused'); } else { puts_clr('Playing'); }
	gotoxy(1,$CursorRow);
}

sub display_recording { my $bar_num = $_[$[];
	gotoxy(1,$CursorRow);
	if (!  defined $RecordingChannel) {
		debug("BUG: display_recording with RecordingChannel undefined");
		gotoxy(1,$CursorRow+2);
		puts_clr("BUG: display_recording with RecordingChannel undefined");
		gotoxy(1,$CursorRow);
		return;
	}
	# red bgd, white fgd
	# BUG if the loop is 1 bar long, the user gets no clue except metronome
	$bar_num += 1;
	my $s = "   \e[41m\e[37m RECORDING  Channel $RecordingChannel ";
	if (defined $bar_num) { $s .= " Bar $bar_num "; }
	$s .= "\e[39m\e[49m ";   # default fgd, default bgd
	puts_clr($s);
}

sub other_loopsets {
	my @other_loopsets = ();
	for my $i (0..$#L) {
		if ($i != $IL) { push @other_loopsets, $i; }
	}
	return @other_loopsets;
}

sub output_patch_changes {
	foreach my $cha (0..15) {
		my $patch = $L[$IL]{'Channels'}[$cha]{'Patch'};
		if (defined $patch) {
			MIDI::ALSA::output(MIDI::ALSA::pgmchangeevent($cha,$patch));
		}
	}
}

sub nonexistent_loopsets {
	return ((1+$#L) .. 15);
}

sub display_loopsets {
	my @s = "We are in Loopset $IL ";
	my @other_loopsets = other_loopsets();
	if (! @other_loopsets) {
		push @s, " (there are no other Loopsets)";
	}  elsif (1 == scalar @other_loopsets) {
		push @s, " (we also have a Loopset $other_loopsets[$[])";
	}  else {
		push @s, " (we also have Loopsets ".join(',', @other_loopsets).")";
	}
	gotoxy(2,2); puts_clr(join('',@s)); gotoxy(1,$CursorRow);
}

sub all_channels {
	my @channels = ();
	foreach my $i (0..15) {
		if (@{$L[$IL]{'Channels'}[$i]{'LoopBars'}}) { push @channels, $i; }
	}
	return @channels;
}

sub display_barlength {
	my @s = "BarLength is $L[$IL]{'BarLength'} sec  ";
	my @channels = all_channels();
	if (! @channels) {
		push @s, " No Channels are set";
	}  elsif (1 == scalar @channels) {
		push @s, " We have Channel ".$channels[$[];
	} else {
		push @s, " We have Channels ".join(',', @channels);
	}
	gotoxy(2,3); puts_clr(join('',@s));
}

sub display_channels {
	display_barlength();
	# " channel 0, patch 4 (Electric Piano), 2 bars, unmuted"
	# " channel 1, patch 32 (Acoustic Bass), 1 bar, unmuted"
	my $y = 4;
	my @channels = all_channels();
	foreach my $cha (@channels) {
		my $muted =   $L[$IL]{'Channels'}[$cha]{'Muted'};
		my $patch =   $L[$IL]{'Channels'}[$cha]{'Patch'};
		my @bars  = @{$L[$IL]{'Channels'}[$cha]{'LoopBars'}};
		my $m = "unmuted"; if ($muted) { $m = "muted"; }
		my $numbars = scalar @bars;
		if (! defined $patch) { $patch = 'not yet set'; }
		gotoxy(2,$y);
		puts_clr("   channel $cha, $m, $numbars bars, patch $patch");
		$y = $y+1;
	}
	$CursorRow = $y;
	gotoxy(1,$CursorRow); clrtoeos();
}

sub display_keystrokes {
	gotoxy(1,$CursorRow); clrtoeos();
	my $y = $CursorRow+1;
	if ($Message) { gotoxy(2,$y);  puts_clr($Message);  $y += 2; } # bold?
	if ($RecordingChannel) {
		gotoxy(2,$y);
		puts_clr("play treble c~~~ to enter play-mode");
	} elsif ($IsCmdMode) {
		# BUT @other_loopsets has already been calculated by display_loopsets
		# and @channels has already been calculated by display_channels ...
		@RelevantCmds = relevant_cmds();  # set this here so others can use it
		my @a = ();
		foreach my $i (@RelevantCmds) { push @a, "$i=$Num2Cmd[$i]"; }
		push @a, "play treble c~~~ to re-enter play-mode";
		my @rows = ();  my $irow = $[;
		foreach my $a_str (@a) {
			if (! $rows[$irow]) {
				$rows[$irow] = $a_str;
			} elsif ((length($rows[$irow]) + length($a_str) + 4) < $COLS) {
				$rows[$irow] = $rows[$irow].',  '.$a_str;
			} else {
				$irow += 1;
				$rows[$irow] = $a_str;
			}
		}
		foreach my $row (@rows) {
			gotoxy(2,$y);   puts_clr($row);  $y += 1;
		}
	} else {
		gotoxy(2,$y);
		puts_clr("play treble c~~~ to enter command-mode");
	}
	gotoxy(1,$CursorRow);
}

sub do_recording {
	if ($L[$IL]{'BarLength'} < 0.9) { ask_barlength();  display_keystrokes(); }
	gotoxy(1,$CursorRow);  clrtoeos();
	my $cha = ask_n("record which channel", $CursorRow, [0..15]);
	if (! defined $cha) { display_keystrokes(); return; }
	my $nbars = ask_n( "channel $cha loop should be how many bars long",
	  $CursorRow, [1..15]);
	if (! defined $nbars) { display_keystrokes(); return; }
	$L[$IL]{'Channels'}[$cha]{'Muted'} = 0;
	$L[$IL]{'Channels'}[$cha]{'Patch'} = $Cha2Patch[$cha];
	$L[$IL]{'Channels'}[$cha]{'LoopBars'} = empty_loop_bars($nbars);
	$WithMetronome = confirm("with metronome");
	$RecordingChannel = $cha;
	display_channels();
	if (! defined $RecordingChannel ) { die "RecordingChannel undefined\n"; }
	# $IsCmdMode = 0;   # play-mode
	$BarCount = -1;
	if ($Paused) {
		$Paused = 0; display_paused();
		Time::HiRes::ualarm(1000);   # start the loop
	}
	display_keystrokes();
	display_recording(1);
	while (1) {
		my @alsaevent = MIDI::ALSA::input();
		if (is_mode_change(@alsaevent)) { undef $RecordingChannel; last; }
		MIDI::ALSA::output(@alsaevent);   # straight-through real-time output
		remember_patch_change(@alsaevent);
		my $cha = $alsaevent[7][0];
		if ((! defined $cha) or ($cha != $RecordingChannel)) { next; }
		my $i_bar = mod_bar_count($cha);
# MUST clear the bar if a note is being recorded into it this time round
		$alsaevent[6] = [0,0];  # so that save-and-restore works reliably
		$alsaevent[4] -= $StartOfBar;
		push @{$L[$IL]{'Channels'}[$cha]{'LoopBars'}[$i_bar]}, \@alsaevent;

	}
	# reduce the NOTEON (6) and NOTEOFFs (7) to NOTEs (5)
	my %pitch2noteon     = ();
	my %pitch2noteonbar  = ();
	my %pitch2noteoff    = ();
	my %pitch2noteoffbar = ();
	my %new_channel  = (
		Muted => $L[$IL]{'Channels'}[$cha]{'Muted'},
		Patch => $L[$IL]{'Channels'}[$cha]{'Patch'},
		LoopBars => []
	);
	my $modbarcount = mod_bar_count();  # race conditions here :-(
	foreach my $ibar (0 .. ($#{$L[$IL]{'Channels'}[$cha]{'LoopBars'}})) {
		push @{$new_channel{'LoopBars'}}, [];
		my @bar_events = sort {$a->[4]<=>$b->[4]}
		  @{$L[$IL]{'Channels'}[$cha]{'LoopBars'}[$ibar]};
		foreach my $event_ref (@bar_events) {
			if ($event_ref->[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEON()) {
				my $pitch = $event_ref->[7][1];
				$pitch2noteon{$pitch} = $event_ref;
				$pitch2noteonbar{$pitch} = $ibar;
			} elsif ($event_ref->[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEOFF()) {
				my $pitch = $event_ref->[7][1];
				if ($pitch2noteon{$pitch}) {
					$pitch2noteon{$pitch}[0]=MIDI::ALSA::SND_SEQ_EVENT_NOTE();
					my $start  = $pitch2noteon{$pitch}[4];
					my $finish = $event_ref->[4];
					$pitch2noteon{$pitch}[7][4] = $finish - $start
					  + $L[$IL]{'BarLength'}*($ibar-$pitch2noteonbar{$pitch});
					push @{$new_channel{'LoopBars'}[$pitch2noteonbar{$pitch}]},
					  $pitch2noteon{$pitch};
					if ($modbarcount >= $pitch2noteonbar{$pitch}
					  and $modbarcount < $ibar) {  # then output the noteoff
						my $cha = $event_ref->[7][0];
						my @off_event=MIDI::ALSA::noteoffevent($cha,$pitch,1,
						 $StartOfBar + $event_ref->[4]
						  + $L[$IL]{'BarLength'}*($ibar-$modbarcount)
						);
						MIDI::ALSA::output(@off_event);
					}
					delete $pitch2noteon{$pitch};
					delete $pitch2noteonbar{$pitch};
				} else {
					$pitch2noteoff{$pitch}    = $event_ref;
					$pitch2noteoffbar{$pitch} = $ibar;
				}
			}
		}
	}
	# if there are noteoffs before their noteons (i.e. round the loop-end)
	foreach my $pitch (keys %pitch2noteon) {
		if ($pitch2noteoff{$pitch}) {
			my $start  = $pitch2noteon{$pitch}[4];
			my $finish = $pitch2noteoff{$pitch}[4];
			$pitch2noteon{$pitch}[0] = MIDI::ALSA::SND_SEQ_EVENT_NOTE();
			$pitch2noteon{$pitch}[7][4] = $finish-$start + $L[$IL]{'BarLength'}
			 * ($pitch2noteoffbar{$pitch} + $nbars - $pitch2noteonbar{$pitch});
			push @{$new_channel{'LoopBars'}[$pitch2noteonbar{$pitch}]},
			  $pitch2noteon{$pitch};
			if ($modbarcount >= $pitch2noteonbar{$pitch}
			  or $modbarcount < $pitch2noteoffbar{$pitch}) {
				my $cha = $pitch2noteon{$pitch}->[7][0];
				my @off_event = MIDI::ALSA::noteoffevent($cha,$pitch,1,
				 $StartOfBar + $finish
				  + $L[$IL]{'BarLength'}*($pitch2noteoffbar{$pitch}-$modbarcount)
				);
				MIDI::ALSA::output(@off_event);
			}
		} else {  # we have a problem...
			debug("noteon without noteoff in the loop; pitch=$pitch");
		}
	}
	$L[$IL]{'Channels'}[$cha] = \%new_channel;
}

sub mod_bar_count { my $cha = $_[$[];
	my $nbars = scalar @{$L[$IL]{'Channels'}[$cha]{'LoopBars'}};
	if (! $nbars) { return 0; }
	return $BarCount % $nbars;
}

sub is_muted {
	my %is_muted = ();  # the ALRM loop only needs to know the unmuted
	foreach my $cha (0..15) {
		my $cha_ref = $L[$IL]{'Channels'}[$cha];
		if ($cha_ref and @{$cha_ref->{'LoopBars'}}) {
			if ($cha_ref->{'Muted'}) { $is_muted{$cha}=1; }
		}
	}
	return %is_muted;
}
sub is_unmuted {
	my %is_unmuted = ();
	foreach my $cha (0..15) {
		my $cha_ref = $L[$IL]{'Channels'}[$cha];
		if ($cha_ref and @{$cha_ref->{'LoopBars'}}) {
			if (! $cha_ref->{'Muted'}) { $is_unmuted{$cha}=1; }
		}
	}
	return %is_unmuted;
}

sub relevant_cmds {
	my @relevant_cmds = ();
	my %is_muted = is_muted();
	my %is_unmuted = is_unmuted();
	#foreach my $cha (0..15) {
	#	my $cha_ref = $L[$IL]{'Channels'}[$cha];
	#	if ($cha_ref) {
	#		my $muted = $cha_ref->{'Muted'};
	#		if ($muted) { $is_muted{$cha}=1; } else { $is_unmuted{$cha}=1; }
	#	}
	#}
	my @other_loopsets = other_loopsets();
	foreach my $i ($[ .. $#Num2Cmd) {
		if ($Num2Cmd[$i] eq 'Play' and $Paused) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'Pause' and ! $Paused) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'Mute' and %is_unmuted) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'Unmute' and %is_muted) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'Record') {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'NewMuteset' and 15 > @other_mutesets) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'GotoMuteset' and @other_mutesets) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'EraseMuteset'
		  and (@Mutesets)) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'NewLoopset'
		  and (@{$L[$IL]{'Channels'}} and 15 > @other_loopsets)) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'GotoLoopset' and @other_loopsets) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'EraseLoopset'
		  and (@{$L[$IL]{'Channels'}} or @other_loopsets)) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'SaveLoopsets'
		  and (@{$L[$IL]{'Channels'}} or @other_loopsets)) {
			push @relevant_cmds, $i;
		} elsif ($Num2Cmd[$i] eq 'Quit') {
			push @relevant_cmds, $i;
		}
	}
	return @relevant_cmds;
}

sub saved_loopsets {
	return glob "$MidiloopDir/*.dump";
}

sub load_loopset { my $file = $_[$[];   # opDir
	if ($file =~ /^\w/) { $file = "$MidiloopDir/$file"; }
	if ($file !~ /\.dump$/) { $file = "$file.dump"; }
	warn " Loaded file $file\n";
	if (! open(F, '<', $file)) { die "can't open $file: $!\n"; }
	my @txt = <F>;
	close F;
	eval join('', @txt);
	if ($@) { die " can't eval $file:\n $@"; }
	# force the MIDI::ALSA channel to conform to the array index
	my $n_corrected = 0;
	foreach my $loopset_ref (@L) {
		#my ($bar_length, @loop_channels) = @{$loopset_ref};
		my $barlength = $loopset_ref->{'BarLength'};
		my @loopchannels = @{$loopset_ref->{'Channels'}};
		foreach my $cha (0 .. $#loop_channels) {
			my ($muted,$patch,@bars) = @{$loop_channels[$cha]};   # XXXX
			foreach my $bar_ref (@bars) {
				foreach my $event_ref (@{$bar_ref}) {
					if ($cha != $event_ref->[7][0]) {
						$n_corrected += 1;
# warn " patch=$patch cha=$cha event_ref->[7][0] was $event_ref->[7][0]\n";
						$event_ref->[7][0] = $cha;
					}
				}
			}
		}
	}
	if ($n_corrected) {
		$Message = "had to correct the channel on $n_corrected notes\n";
	}
	if ($IL > $#{$L}) { $IL = 0; }
	return 1;
}


sub handle_command { my $cmd = $_[$[];
	if ($cmd eq 'Play') {
		$Paused = 0; display_paused(); display_keystrokes();
		Time::HiRes::ualarm(1000);   # wait 1 mS, and restart the loop
	} elsif ($cmd eq 'Pause') {
		$Paused = 1; display_paused(); display_keystrokes();
	} elsif ($cmd eq 'Mute') {
		my %is_unmuted = is_unmuted();
		my @are_unmuted = sort {$a<=>$b} keys %is_unmuted;
		my $cha = ask_n("mute which channel", $CursorRow, \@are_unmuted);
		if (! defined $cha) { display_keystrokes(); return; }
		$L[$IL]{'Channels'}[$cha]{'Muted'} = 1;
		display_channels();
	} elsif ($cmd eq 'Unmute') {
		my %is_muted = is_muted();
		my @are_muted = sort {$a<=>$b} keys %is_muted;
		my $cha = ask_n("unmute which channel", $CursorRow, \@are_muted);
		if (! defined $cha) { display_keystrokes(); return; }
		$L[$IL]{'Channels'}[$cha]{'Muted'} = 0;
		display_channels();
	} elsif ($cmd eq 'Record') {
		do_recording();
		display_keystrokes();
	} elsif ($cmd eq 'EraseLoopset') {
		my @loopsets = $[..$#L;
		my $loopset = ask_n("erase which Loopset", $CursorRow, \@loopsets);
		if (defined $loopset and confirm("OK to erase loopset $loopset")) {
			splice(@L, $loopset,1);
			if ($IL > $loopset) {
				$IL -= 1;
			} elsif ($IL == $loopset) {
				$IL = 0;
			}
		}
	} elsif ($cmd eq 'NewLoopset') {
		if (16 <= @L) { next; }
		$NextLoopset = $#L + 1;
	} elsif ($cmd eq 'GotoLoopset') {
		my @other_loopsets = other_loopsets();
		if (! @other_loopsets) { next; }
		my $next_loopset
		  = ask_n(' go to which Loopset', $CursorRow, \@other_loopsets);
		if (! defined $next_loopset) { next; }
		$NextLoopset = $next_loopset;
		display_loopsets();
	} elsif ($cmd eq 'SaveLoopsets') { # use Dumper, not .mid, for load-speed
		# save the loopset (into ~/midiloop/ or $MIDILOOP_DIR)
		#     (automatically assigns it a date-based filename.dump)
		#     save multiple just by pressing multiple numbers, then 
		if (! -d $MidiloopDir and ! mkdir $MidiloopDir) {
			$Message = "can't mkdir $MidiloopDir: $!\n"; return;
		}
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
		my $filename = sprintf ("%4.4d%2.2d%2.2d_%2.2d%2.2d",
		  $year+1900, $mon+1, $mday, $hour, $min);
		if (! open(F, '>', "$MidiloopDir/$filename.dump")) {
			$Message = "can't open file $MidiloopDir/$filename.dump: $!\n";
			return;
		}
		$L[$IL] = {
			BarLength=>$L[$IL]{'BarLength'}, Channels=>$L[$IL]{'Channels'}
		};
		print F dump_text(@L);
		close F;
		$Message = "saved to file $MidiloopDir/$filename.dump";
	} elsif ($cmd eq 'LoadLoopsets') { # But how to fileselect ?
		# load a loopset   (if there is one in ~/midiloop/ or $MIDILOOP_DIR)
		#     (automatically assigns it to the lowest free loopset-number)
		#     buy how can the user choose which one ?
	} elsif ($cmd eq 'Quit') { # But how to fileselect ?
		if (confirm("OK to Quit")) { exit; }
	}
}

sub dump_text {
	my @lines = split /\n/, Data::Dumper::Dumper(\@L);
	$lines[0] = "\@L = (";
	$lines[$#lines] = ");";
	my $in__an_event = 0;
	my $loopset_num = 0; 
	my $channel_num = 0; 
	my $line_in_cha = 0; 
	foreach my $line (@lines) {
		$line .= "\n";
		$line =~ s/^        //;
		$line =~ s/^              //;
		$line =~ s/^              //;
		$line =~ s/(\d\d\d\d\d)\d+/$1/;
		if ($line eq       "            [\n") {
			$in__an_event = 1;
			$line = "            [";
		} elsif ($line =~ /^            ],?\n/) {
			$in__an_event = 0;
			$line =~ s/^\s+//;
		} elsif ($in__an_event) {
			$line =~ s/^\s+//;
			$line =~ s/\n$//;
		} elsif ($line =~ /^  {/) {
			$line =~ s/\n/  # Loopset $loopset_num\n/;
			$loopset_num += 1;
			$channel_num = 0;
		} elsif ($line =~ /'BarLength'/) {
			$line =~ s/\n/  # (secs)\n/;
		} elsif ($line =~ /^      {?},/) {
			$channel_num += 1;
			$line_in_cha = 0; 
		} elsif ($line =~ /^      {/) {
			if ($line_in_cha == 0) {
				$line =~ s/\n/  # Channel $channel_num\n/;
				$line_in_cha = 0; 
			}
			$line_in_cha += 1; 
		}
	}
	return join('', @lines);
}

sub remember_patch_change { my @alsaevent = @_;
	if ($alsaevent[0] == MIDI::ALSA::SND_SEQ_EVENT_PGMCHANGE()) {
		my $cha = $alsaevent[7][0];  # should factor this out w record
		$Cha2Patch[$cha] = $alsaevent[7][5];
		if (%{$L[$IL]{'Channels'}[$cha]}) {
			$L[$IL]{'Channels'}[$cha]{'Patch'} = $Cha2Patch[$cha];
			display_channels();
		}
	}
}

sub confirm {   # returns true or false
	return ask_n("$_[$[] (0=No 1=Yes) ?", $CursorRow, [0,1]);
}

sub ask_barlength {
	my @s1 = ();  my @s2 = ();
	foreach my $i (0..7) { push @s1, "$i=$Num2Barlength[$i]"; }
	gotoxy(2,$CursorRow+1); puts_clr(join '   ',@s1);
	foreach my $i (8..15) { push @s2, "$i=$Num2Barlength[$i]"; }
	gotoxy(2,$CursorRow+2); puts_clr(join '   ',@s2);
	my $n = ask_n("at what Barlength ?", $CursorRow, [0..15]);
	gotoxy(1,$CursorRow); clrtoeos();
	$L[$IL]{'BarLength'} = $Num2Barlength[$n];
	display_barlength();
}

sub ask_n {   my ($msg, $row, $aref) = @_;  # returns a number 0..15
	if (! $row) { $row = $CursorRow; }    # to place it within the UI
	my @a = sort {$a<=>$b} @{$aref};   # allows only a subset of answers
	my $a_str = join(',',@a);
	if (! @a) { @a = (0..15); $a_str = '0..15';
	} elsif (2 < @a and (1 + $a[$#a] - $a[$[]) == scalar @a) {
		$a_str = "$a[$[]..$a[$#a]";
	}
	my %is_ok_num = map { $_, 1 } @a;
	# perhaps we need a Cancel D#=63,F#4=78 ? (returning -1 or undefined)
	my $just_waiting_for_a_noteoff = 0;
	my $number;
	gotoxy(1,$row); puts_clr("  $_[$[] ($a_str) ? ");
	while (1) {
		my @alsaevent = MIDI::ALSA::input();
		my $cha = $alsaevent[$#alsaevent][0];
		if ($alsaevent[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEON()) {
			my $pitch = $alsaevent[$#alsaevent][1];
			if ($pitch == $ModeChangeKey) { return undef; }
			if ($pitch < 48) {
				%Pitch2Number = %Pitch2Number49;
			} elsif ($pitch > 64) {
				%Pitch2Number = %Pitch2Number88;
			}
			$number = $Pitch2Number{$pitch};
			if ($is_ok_num{$number}) {
				puts_clr("$number"); gotoxy(1,$row);
				$just_waiting_for_a_noteoff = 1;
			}
		} elsif ($just_waiting_for_a_noteoff
		  and $alsaevent[0] == MIDI::ALSA::SND_SEQ_EVENT_NOTEOFF()) {
			return $number;
		}
		# we do something to throw away the corresponding note-off,
		# otherwise it gets recorded in the loop
	}
}

# ---------- vt100 stuff, evolved from Term::Clui via midiecho ----------

sub puts   { my $s = join q{}, @_;
	$Irow += ($s =~ tr/\n/\n/);
	if ($s =~ /\r\n?$/) { $Icol = 1;
	} else { $Icol += length($s);   # BUG, wrong on multiline strings!
	}
	print STDERR $s;
}
sub puts_30c {  my $s = $_[$[];   # assumes no newlines
	my $rest = 30-length($s);
	print STDERR $s, " "x$rest, "\e[D"x$rest;
	$Icol += length($s);
}
sub puts_clr {  my $s = $_[$[];   # assumes no newlines
	$s =~ s/\s/ /g;
	print STDERR "$s\e[K";
	$Icol += length($s);
}
sub clrtoeol {
	print STDERR "\e[K";
}
sub clrtoeos {
	print STDERR "\e[J";
}
sub up	{
	print STDERR "\e[A" x $_[$[]; $Irow -= $_[$[];
}
sub down  {
	print STDERR "\n" x $_[$[]; $Irow += $_[$[];
	$Icol=1;
}
sub right {
	print STDERR "\e[C" x $_[$[]; $Icol += $_[$[];
}
sub left  {
	print STDERR "\e[D" x $_[$[]; $Icol -= $_[$[];
}
sub gotoxy { my $newcol = shift; my $newrow = shift;
	$newcol = round($newcol); $newrow = round($newrow);
	if ($newrow > $Irow)      { down($newrow-$Irow);   # down can affect Icol
	} elsif ($newrow < $Irow) { up($Irow-$newrow);
	}
	if ($newcol <= 1) { print STDERR "\r" ; $Icol = 1;
	} elsif ($newcol > $Icol) { right($newcol-$Icol);
	} elsif ($newcol < $Icol) { left($Icol-$newcol);
	}
}

__END__

=pod

=head1 NAME

midiloop - Makes multiple sets of multi-channel MIDI loops

=head1 SYNOPSIS

 # You'll need a midi-keyboard (88-note is best) from which you can
 # see a console (or xterm or terminal). Once midiloop is launched,
 midiloop -i ProKeys -o MySynth
 # all the user-interface is driven by the keys of the midi-keyboard.
 # The console (or xterm) tells you what the current status is and
 # what your options are,
 # and the top note of the keyboard (by default treble c~~~ = midi 108)
 # switches you into and out of command-mode.
 # All choices are made using the numbers 0..15,  which are mapped
 # on an 88-note keyboard to notes treble D to e~ (midi 62 to 88)

 midiloop -i Keystation -k 49   # use my 49-note keyboard,
 # on which 0..15 are mapped to notes bass D to e~ (midi 38 to 64)

 # Saved loopsets are expressed in Perl, the notes in MIDI::ALSA format
 midiloop -i Pro -l 201302_1452  # loads a previously saved loopset
 cd ~/midiloop ; ls -l           # inspect the saved loopsets
 perldoc MIDI::ALSA     # for the event format see the "input" function
 vi ~/midiloop/201302_1452.dump  # edit a loopset file (in Perl)

 midiloop -v            # prints the version
 perldoc midiloop       # read the manual :-)

=head1 DESCRIPTION

midiloop creates an ALSA-MIDI client, and records and replays sets of loops.
There can be up to sixteen Loopsets.
Each loopset can have up to sixteen midi-channels,
each of which can be muted or unmuted.

Each loopset has a basic barlength in seconds,
but each channel within that loopset can loop at an integer multiple (1..15)
of that basic barlength.
For example, the drums could loop at 1.8 seconds,
but the bass could play a 3.6-second riff,
and the organ could play a 7.2-second sequence.

The user-interface depends on the computer-screen being
visible by the performer,
but it uses the notes of the midi-keyboard to get user-input,
not the keys of the computer-keyboard.
This leads to fast operation in a performance situation.

and allows a whole set-up, with several loops and many channels,
to be stored on disc as notes in a standard midi-file.

=head1 LOOPS

I divide the world into four major types of loop.

In the B<new-wave loop> (the B52's, Television, Talking Heads)
there are several voices that share a common pulse (egale, not swung).

In a B<jazz loop> the voices share a common swung (inegale) pulse.

In the B<supple groove> the instruments don't keep a common beat,
but they do loop at rigorously the same barlength.
So they might be out of phase, but they remain locked accurately out of phase;
the phase may be random, but the period is exact.

In B<psychedlic loops> there are several loops of different periods;
to do this with I<midiloop> you need several I<midiloop>s running
simultaneously.

=head1 TO DO

Midiloop with rabbit and mt2 as well as just cycle.

Midiloop with a "this is the ending" Loopset, which doesn't loop

Plus a Loopset should also have comments etc,
even if this can only be set by vi ~/midiloop/whatever.dump

This means more data at the Loopset and at the Channel level,
so both Loopset and Channel are going to have to be hashrefs not arrayrefs,
which indeed they are, as from version 2.0.

=head1 OPTIONS

=over 3

=item I<-d ~/otherstuff/wierdgrooves/>

Over-ride the default I<~/midiloop/> directory,
and also the environment variable I<$MIDILOOP_DIR>, if that's set.

=item I<-i Keyst:1>

Connect the B<I>nput from ALSA-MIDI client I<Keyst:1>

=item I<-k 49>

Tells I<midiloop> which size keyboard you'll be using.
The default is 88; the other available values are 49 and 25.
(61 is not supported yet).  This affects the ModeChangeKey
which is always the top note on the keyboard, and the keys
entering the numbers 0 to 15,
which on an 88-note keyboard are the white notes treble D to e~,
and on an 49-note keyboard are two octaves lower, bass D to e~.
These conventions are modelled on the Channel-entry keys used by M-Audio
(counting channels 0..15 of course :-).
If you have to use a 25-note keyboard, they are currently
the chromatic scale treble D to B, which only allows you 0 to 9 :-(

=item I<-l 20130214_1425>

Loads the previously saved Loopset I<20130214_1425.dump>,
probably from the user's I<~/midiloop/> directory,
though this can be over-ridden with the environment variable I<$MIDILOOP_DIR>
or with the B<-d> option.

The Loopsets are saved in Perl I<Data::Dumper> format,
but with helpful added comments to tell you which Loopset, Channel and Bar
you're in. The file can be edited with some care and a text-editor.
The events are I<MIDI::ALSA> events, as documented in
I<perldoc MIDI::ALSA> in the section on the function I<input()>

=item I<-o Syn>

Connect the B<O>utput to ALSA-MIDI client I<Syn>.
The special value I<-o 0> tells midiloop not to connect to any other client.
If the I<-o> option is not specified,
the default is the environment variable I<$ALSA_OUTPUT_PORTS>

=item I<-v>

Print the Version

=back

=head1 DOWNLOAD

midiloop at is available at
 http://www.pjb.com.au/midi/midiloop.html

It uses the MIDI::ALSA module which is available at
 http://search.cpan.org/perldoc?MIDI::ALSA

=head1 CHANGES

 20130224 2.0 shorter varnames; @LoopChannels convenience-var eliminated
 20130223 1.9 each LoopChannel is a hashref
 20130222 1.8 each Loopset is a hashref
 20130221 1.7 LoadLoopset corrects the channel if necessary
 20130209 1.6 Loopsets stored in NOTE-form; SaveLoopset much improved
 20130207 1.5 SaveLoopset works
 20130103 1.4 starting the change to Loopsets, BarLengths, NumBars
 20121024 1.3 overdubbing, muting, replacing any channel
 20120929 1.2 convert NOTEONs unterminated in the loop to NOTEs
 20120922 1.1 seems to respond correctly to the Pedal :-)
 20120909 1.0 forked from an old fade-based midiecho-like version

=head1 AUTHOR

Peter J Billam, http://www.pjb.com.au/comp/contact.html

=head1 SEE ALSO

 http://www.pjb.com.au/
 http://www.pjb.com.au/midi/
 http://www.pjb.com.au/midi/midiloop.html
 http://search.cpan.org/perldoc?MIDI::ALSA
 http://www.pjb.com.au/comp/lua/midialsa.html#input

=cut
